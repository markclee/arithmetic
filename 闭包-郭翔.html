<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		/*什么是闭包:
			闭包是一个绑定执行环境的函数,携带执行环境
		  什么是执行上下文
			-javascript标准把一段代码(包括函数),执行所需要的所有信息,称为执行上下文
			-执行上下文,在es2018中定义
				lexical environment：词法环境，当获取变量或者this时使用
				variable environment：变量环境，当声明变时使用
				code evaluation state：用于恢复代码执行位置
				Function：执行的任务是函数时使用，表示正在被执行的函数
				ScriptOrModule：执行的任务是脚本或者模块时使用,表示正在被执行的代码
				Realm：使用的基础库和内置对象实例。
				Generator：仅生成器上下文有这个属性，表示当前生成器
		*/
		//自执行函数,匿名函数自调用,存在弊端,两个自执行函数之间必须写分号(区分开,谁调用的谁)
		//因为自执行函数不需要return值,所以可以使用void的新写法,更符合语义
		void function(){
			console.log('123')
		}()
		
		//with作用域里,访问对象的属性,不需要写对象前缀
		var b;
        void function(){
            var env = {b:1}
            b = 2//此处篡改了b的值,根据作用局查找规则,由内向外,里边的可以访问外边的变量,外边的不能访问里边的变量
			//var b = 2 不会篡改b的值
            console.log('in b:', b)  //2
            with(env){
                var b = 3
                console.log('in with b:', b)  //3
            }
        }()
        console.log('global b', b) // 2
		//------------------------------------------------------------------------------------------------------
		/*js中切换 上下文最主要的场景就是函数调用*/
		
		
		/**************************利用闭包在函数外部获取函数内的值****************************/ 
		/*--当函数体内有一些数据或内容被函数外部占用的时候，这个空间不会被销毁，这个不被销毁的空间叫做闭包
			
			--这个空间不被销毁
			--因为函数的作用域关系，函数内部的变量不能被外界访问
		*/
		// function fn(){
		// 	var num = 10;
		// 	// 为了es6的代码糖考虑
		// 	return function() {
		// 		return num;
		// 	}
		// }
		// var a = fn();
		// var b = a();
		// console.log(b);

		/****************利用闭包在函数外部设置函数内的值****************/
		// function fn(){
		// 	var num = 10;
		// // 这个值会被改变吗？

		// 	// 为了es6的代码糖考虑
		// 	return function(n) {
		// 		num += n;
		// 		return num;
		// 	}
		// }
		// var a = fn();
		// var b = a(10);
		// console.log(b);


/******************************************/
		// function fn(){
		// 	var num = 10;


		// 	// 为了es6的代码糖考虑
		// 	return {
		// 		getNum : function() {
		// 			return num;
		// 		},
		// 		setNum : function(n) {
		// 			num += n;
		// 			// return num;
		// 		}
		// 	}
		// }
		// var a = fn();
		// var b = a.getNum()
		// console.log(b);
		// a.setNum(10);
		// var c = a.getNum()
		// console.log(c);


		/**************代码糖写法***************/
		function fn(){
			var num = 10;
			var num2 = 100;
			return {
				get getNum(){
					return num;
				},
				set setNum(n){
					num += n;
				},
				get getNum2(){
					return num2;
				}
			}
		}

		// get set是关键字
		var a = fn();
		console.log(a.getNum)
		a.setNum = 10;
		console.log(a.getNum)
		console.log(a.getNum2)

		 // 闭包作用：
		 // 1：保护私有变量，防止全局变量污染
		 // 2：让函数外部可以操作函数内部的属性或者数据
		 // 3：操作性能很好的封装底层代码

		 // 沙箱模式：代码糖的的闭包写法就是沙箱模式
		 // 科利华函数 callback回调函数
	</script>
</body>
</html>