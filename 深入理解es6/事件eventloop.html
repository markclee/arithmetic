<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*  tick:一次循环
            task:循环里执行的任务

            +事件循环:总是查找新事件并执行,一次循环的执行称为tick,在这个循环里执行的代码称为task
                tasks(任务)中,同步执行的代码可以在循环中生成新的任务
                    - setTimeout(taskFn,delay)
                    - 用户事件
                    - 网络事件
                    - DOM的绘制
            +任务队列
                - 同一个tick, 有几种任务队列
                - 同一个任务队列中
                    -必须是同一个任务源中的事件
                    -按照每个队列中,插入的顺序处理任务
                    -例如
                        - setTimeout setInterval在一个task中,网络io在一个task中,用户事件在一个io中
                - 执行环境
                    - 决定下一步处理哪些队列
                    - 意味着,我们可能会失去对 事件执行时间 控制权
                    - 例如:在一个tick中,有setTimeout创建的任务,有事件创建的任务,当执行环境
                          决定执行setTimeout这个任务之前,会清空事件创建的任务
            +MicroTask queue
                - MicroTask执行时间
                    - 在task队列执行完毕后在执行
                - MicroTask
                    - 只有一个microtask任务队列,microtask可以生成新的microtask任务,插入到同样的队列尾部
                      在一个tick中执行
                - Promise.resolve().then(microtaskFn)
            +渲染
                - 运行在每个tick结束后的算法,可能在每个任务队列后执行渲染,也可能执行多个任务队列,不渲染
                - requestAnimationFrame(handle)
        */ 
        /*
            eventloop 事件循环,因为v8是单线程的,同一个时间只能干一件事,文件读取,网络IO处理缓慢
                      不同的异步事件,加入不同的任务队列,
        
            执行顺序
                updata_time 
                    - 事件循环开头,获取系统时间,确保之后的timer准确触发
                timer
                    - 检查是否有到期的timer(setTimeout setInterval的timer) 到期了,执行他们的回调
                I/O callbacks
                    - 处理异步事件的回调,网络I/O 文件读取I/O,当这些I/O动作都结束了,在这个阶段触发他们的回调
                idle prepare
                    - 处理内部动作
                I/O poll
                    - 选择运行的,不一定会执行
                check
                    - 执行setLmmediate操作
                close callbacks 
                    - 关闭I/O动作,文件描述符关闭,连接断开等
            microTask任务
                - microTask queue只有一个,一定会在每个Task后执行,顺序执行
                - eventloop会在执行完microTask后才寻找新的可执行的task队列
                - microTask事件内部可以生产新的microTask事件
            渲染事件队列
                - 队列只出现在浏览器上,根据执行环境决定是否执行
                - 如果执行,一定在microTask之后执行
                - 通过requestAnimationFrame(handle)方法,保证中间的代码一定在执行渲染函数之前执行
            常见的microTask事件
                - process.nextTick
                - promise
                - Object.observe
                - MutationObserve
            常见的Tasks事件
                - setTimeout
                - setInterval
                - setImmediate
                - I/O
                - UI渲染
            https://github.com/zhousg/Algorithm/blob/master/docs/%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82EventLoop.md
        
        */ 
    
    </script>
</body>
</html>